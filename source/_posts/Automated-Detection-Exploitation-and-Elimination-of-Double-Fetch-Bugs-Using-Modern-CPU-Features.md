---
title: >-
  Automated Detection Exploitation and Elimination of Double-Fetch Bugs Using
  Modern CPU Features
date: 2019-02-05 10:50:59
tags:
- Double-Fetch Bugs
- AsiaCCS'18
- 2018年
categories:
- 论文
- fuzzing
---

# Abstract

Double-fetch bugs 是一种特殊的条件竞争，在高权限线程的time-of-check和time-of-use之间，低权限线程能够修改共享的内存，导致高权限线程访问的内存产生不一致。本文作者提出了一种检测，利用并消除double-fetch bugs的技术DECAF和Dropit。总体来说，***贡献如下：1. 把cache attack与kernel fuzzing结合起来。2. 首个自动化的挖掘double-fetch bugs的方法。3. 利用的成功率高达97%。4.利用Hardware Transactional Memory的特性，消除double-fetch bugs。5.方法对fuzz TEE也有效。***



| relevant information |                                                              |
| -------------------- | ------------------------------------------------------------ |
| *作者*               | Michael Schwarz, Daniel Gruss, Moritz Lipp, Clémentine Maurice, Thomas Schuster, Anders Fogh, Stefan Mangard |
| *单位*               | Graz University of Technology, CNRS, G DATA Advanced Analytic |
| *出处*               | AsiaCCS’18                                                   |
| *原文地址*           |                                                              |
| *源码地址*           |                                                              |
| *发表时间*           | 2018年                                                       |

# 简介

现代操作系统的安全依赖操作系统kernel提供隔离性，在对kernel的攻击中，条件竞争是一个很难解决的问题。Double-fetch bugs 就是一种特殊的条件竞争。kernel两次访问同一块内存，首先检查数据的合法性，第二次就使用它，那在这两者之间，内存可能被修改。 Double Fetches有个明显的特征是要访问两次内存。如果数据在cache中，就从cache中读，如果不在就从主存中读到cache中，基于cache的攻击，比如著名的Flush+Reload攻击，可以利用CPU的这个特性来检测Double Fetches。

Intel TSX的hardware transactional memory特性能够保证当数据被读进transaction后，数据不能被任何transaction之外的操作修改。这种特性被用来实现安全加固，比如在这个场景中就可以天然的防御Double Fetch bugs。

![](E:\github\hexo\source\_posts\Automated-Detection-Exploitation-and-Elimination-of-Double-Fetch-Bugs-Using-Modern-CPU-Features\1.jpg)

- 通过Flush+Reload边信道检测double fetches
- 判断double fetches是否能够被利用
- 通过hardware transactional memory消除double fetch bugs

# 检测

主要思想是监控cache访问syscall的参数（比如指针，结构体中的指针），筛选出这些指针后，另起一个Flush+Reload线程对这些指针进行监控。

效果如下所示，可以明显的看到两次cache的访问。

![](E:\github\hexo\source\_posts\Automated-Detection-Exploitation-and-Elimination-of-Double-Fetch-Bugs-Using-Modern-CPU-Features\2.jpg)

## 多次cache hit的分类

影响cache acess pattern的因素

- size of data type
- parameter reuse

## 检测的概率

检测成功的概率取决于两次访问时间的间隔。因为本身Flush+Reload需要把数据从cache中清掉，这要消耗大概200多个CPU周期，这就要保证double fetch的两次访问间隔至少要是Flush+Reload两倍的的时间才行。 

![](E:\github\hexo\source\_posts\Automated-Detection-Exploitation-and-Elimination-of-Double-Fetch-Bugs-Using-Modern-CPU-Features\3.jpg)

## TrinityDECAF

作者基于trinity这个kernel syscall fuzz框架，实现了 TrinityDECAF，架构如图，基于trinity，为每个syscall的参数实现了一个监控的进程。

![](E:\github\hexo\source\_posts\Automated-Detection-Exploitation-and-Elimination-of-Double-Fetch-Bugs-Using-Modern-CPU-Features\4.jpg)

# 利用

Flush-Reload or Flush+Flush

fuzz策略

- 参数值改成0
- 翻转最低有效比特
- 增加值
- 参数值改为随机值

# 消除

作者实现了Dropit的库，这个是基于硬件的特性，hardware transactional memory保证了两次内存访问之间不能再对该内存修改。实现起来也很简单，使用Intel TSX的XBEGIN和XEND指令讲存在bug的代码包起来即可。

![](E:\github\hexo\source\_posts\Automated-Detection-Exploitation-and-Elimination-of-Double-Fetch-Bugs-Using-Modern-CPU-Features\5.jpg)

# 评估

## DECAF

已知漏洞CVE-2016-6516 

![](E:\github\hexo\source\_posts\Automated-Detection-Exploitation-and-Elimination-of-Double-Fetch-Bugs-Using-Modern-CPU-Features\6.jpg)

- 可行性

![](E:\github\hexo\source\_posts\Automated-Detection-Exploitation-and-Elimination-of-Double-Fetch-Bugs-Using-Modern-CPU-Features\7.jpg)

- 有效性

![](E:\github\hexo\source\_posts\Automated-Detection-Exploitation-and-Elimination-of-Double-Fetch-Bugs-Using-Modern-CPU-Features\8.jpg)

- 利用的成功率

![](E:\github\hexo\source\_posts\Automated-Detection-Exploitation-and-Elimination-of-Double-Fetch-Bugs-Using-Modern-CPU-Features\9.jpg)

- 在TEE上fuzz

![](E:\github\hexo\source\_posts\Automated-Detection-Exploitation-and-Elimination-of-Double-Fetch-Bugs-Using-Modern-CPU-Features\10.jpg)

- 使用dropit和不使用的比较

![](E:\github\hexo\source\_posts\Automated-Detection-Exploitation-and-Elimination-of-Double-Fetch-Bugs-Using-Modern-CPU-Features\11.jpg)

参考于GoSSIP.









